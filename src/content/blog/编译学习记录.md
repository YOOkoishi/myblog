---
title: 编译学习笔记
description: 学习编译过程中的记录
pubDate: 2025-9-10
image: /image/compliers.png
categories:
  - tech
tags:
  - 编译器
  - compliers
  - 学习笔记
---

# 前言

本篇博客主要记录我学习 complier 的过程.

主要参考实验:[PKU编译原理实验](https://pku-minic.github.io/online-doc/#/)

主要参考书籍: 《编译器设计(第二版)》、《编译方法、技术与实践》

# 正文

9-10

## Lv0. 环境配置

记录一下上一周完成的：根据北大编译实验在线文档完成了Lv0.环境配置
配置了docker源，并且根据docker写了一个启动脚本，我选择了c/c++路线使用cmake进行编译。

脚本如下：

```sh
#!/bin/bash

docker run -it --rm -v $(pwd):/root/compiler maxxing/compiler-dev bash -c "
    cd compiler &&
    cmake -DCMAKE_BUILD_TYPE=Debug -B build &&
    cmake --build build &&
    cd build &&
    bash
"
```

其中第一行是根据 Maxxing 的 docker run 脚本改的启动脚本，使用了 `$(pwd)` 增加脚本的通用性.

后面的内容很容易理解.

## Lv1. main函数

### Lv1.1. 编译器的结构

编译器通常由以下几个部分组成:

- 前端: 通过词法分析和语法分析, 将源代码解析成抽象语法树 (abstract syntax tree, AST). 通过语义分析, 扫描抽象语法树, 检查其是否存在语义错误.
- 中端: 将抽象语法树转换为中间表示 (intermediate representation, IR), 并在此基础上完成一些机器无关优化.
- 后端: 将中间表示转换为目标平台的汇编代码, 并在此基础上完成一些机器相关优化.

一些英文用语

- 词法分析器 (lexer)
- 语法分析器 (parser)
- 字节流 (byte stream)
- 单词流 (token stream)
- 中间表示 (IR)
- 抽象语法树 (AST)

词法分析的作用, 是把字节流转换为单词流 (token stream).
语法分析的目的, 按照程序的语法规则, 将输入的 token 流变成程序的 AST.
在语法分析的基础上, 编译器会对 AST 做进一步分析, 以期 “理解” 输入程序的语义, 为之后的 IR 生成做准备.
编译器通常会将 AST 转换为另一种形式的数据结构, 我们把它称作 IR. IR 的抽象层次比 AST 更低, 但又不至于低到汇编代码的程度. 在此基础上, 无论是直接把 IR 进一步转换为汇编代码, 还是在 IR 之上做出一些优化, 都相对更容易.（比较出名的LLVM 里面就有很多IR）
编译器进行的最后一步操作, 就是将 IR 转换为目标代码, 也就是目标指令系统的汇编代码.

<br>

### Lv1.2. 语法/词法分析初见

由于生在一个好时代，我们想要实现一个效率蛮不错的词法/语法分析器，并不需要手写递归下降分析器。不过我先在这里放一个网址，可以以后留着来看 [Kaleidoscopea](https://llvm.org/docs/tutorial/MyFirstLanguageFrontend/LangImpl01.html).
现在的工具可以根据正则表达式和 EBNF 生成词法/语法分析器.

EBNF, 即 [Extended Backus–Naur Form](https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form), 扩展巴科斯范式, 可以用来描述编程语言的语法.

 9-11

示例：

```c
int main() {
  // 忽略我的存在
  return 0;
}
```

的语法用EBNF表示为

```ebnf
CompUnit  ::= FuncDef;

FuncDef   ::= FuncType IDENT "(" ")" Block;
FuncType  ::= "int";

Block     ::= "{" Stmt "}";
Stmt      ::= "return" Number ";";
Number    ::= INT_CONST;
```

通过推导可以得到

```ebnf
"int" IDENT "(" ")" "{" "return" INT_CONST ";" "}"
```

由于活在一个好的时代，在C/C++中，我们可以使用 Flex 和 Bison 来分别生成词法分析器和语法分析器.

- Flex 用来描述 EBNF 中的终结符部分, 也就是描述 token 的形式和种类. 你可以使用正则表达式来描述 token.
- Bison 用来描述 EBNF 本身, 其依赖于 Flex 中的终结符描述. 它会生成一个 LALR parser.

关于 Flex 和 Bison 的学习，Maxxing 推荐参考 [Calc++](https://www.gnu.org/software/bison/manual/html_node/A-Complete-C_002b_002b-Example.html) 这里先行放置一下，等以后过来可以学习一下.

Flex 将会读取 `*.l` 文件中描述的词法规则，Bison 将会读取 `*.y` 文件中描述的语法规则.由于这两个文件是互相依赖的 由于 Flex 和 Bison 生成的 lexer 和 parser 会互相调用, 所以这两个文件里的内容也相互依赖.

这两种后缀的文件的结构都是：

```bison
// 这里写一些选项, 可以控制 Flex/Bison 的某些行为

%{

// 这里写一些全局的代码
// 因为最后要生成 C/C++ 文件, 实现主要逻辑的部分都是用 C/C++ 写的
// 难免会用到头文件, 所以通常头文件和一些全局声明/定义写在这里

%}

// 这里写一些 Flex/Bison 相关的定义
// 对于 Flex, 这里可以定义某个符号对应的正则表达式
// 对于 Bison, 这里可以定义终结符/非终结符的类型

%%

// 这里写 Flex/Bison 的规则描述
// 对于 Flex, 这里写的是 lexer 扫描到某个 token 后做的操作
// 对于 Bison, 这里写的是 parser 遇到某种语法规则后做的操作

%%

// 这里写一些用户自定义的代码
// 比如你希望在生成的 C/C++ 文件里定义一个函数, 做一些辅助工作
// 你同时希望在之前的规则描述里调用你定义的函数
// 那么, 你可以把 C/C++ 的函数定义写在这里, 声明写在文件开头
```

实验中给出的实例代码可以在 [这里](https://pku-minic.github.io/online-doc/#/lv1-main/lexer-parser?id=cc-%e5%ae%9e%e7%8e%b0) 看一看.

在誊抄了lab中的代码后，我也是成功运行了这个简易 “编译器” 了.

当然，运行complier的时候记得参数中文件的地址，比如示例文件中 `hello.c` 在 `../` 中，别忘了修改参数，不然会报错

```sh
compiler: /root/compiler/src/main.cpp:27: int main(int, const char **): Assertion `yyin' failed.
Aborted (core dumped)
```

9-14

强烈推荐使用 VScode 中的 `Yash` 插件,可以高亮 `Flex` & `Bison` 的语法以及纠错.

在 `parser` 里可以使用 `unique_ptr` 智能指针来很好的减轻内存管理的压力.

**基本特性:**

- 自动管理内存（RAII）
- 独占所有权（不能复制，只能移动）
- 离开作用域时自动删除所指向的对象

**示例:**

```cpp
#include <memory>
#include <string>

// 基本使用示例
void uniquePtrBasics() {
    // 创建 unique_ptr
    std::unique_ptr<std::string> ptr1 = std::make_unique<std::string>("Hello");
    
    // 或者使用 new（不推荐）
    std::unique_ptr<std::string> ptr2(new std::string("World"));
    
    // 访问内容
    std::cout << *ptr1 << std::endl;        // 解引用
    std::cout << ptr1->length() << std::endl; // 成员访问
    
    // 移动语义（转移所有权）
    std::unique_ptr<std::string> ptr3 = std::move(ptr1);
    // 现在 ptr1 为空，ptr3 拥有字符串
    
    // 离开作用域时自动删除内存
}
```

Union 联合体

**基本特性:**

- 所有成员共享同一块内存
- 大小等于最大成员的大小
- 同一时间只能使用其中一个成员

**示例**

```cpp
// 基本 union 示例
union BasicUnion {
    int int_val;
    float float_val;
    char char_val;
};

int main() {
    BasicUnion u;
    
    // 只能同时使用一个成员
    u.int_val = 42;
    cout << "int: " << u.int_val << endl;  // 输出: 42
    
    u.float_val = 3.14f;
    cout << "float: " << u.float_val << endl;  // 输出: 3.14
    cout << "int: " << u.int_val << endl;      // 输出: 垃圾值，因为被覆盖了
    
    return 0;
}
```

<br>

### Lv1.3. 解析main函数

本节的内容需要我处理以下EBNF:

```ebnf
CompUnit  ::= FuncDef;

FuncDef   ::= FuncType IDENT "(" ")" Block;
FuncType  ::= "int";

Block     ::= "{" Stmt "}";
Stmt      ::= "return" Number ";";
Number    ::= INT_CONST;
```

我使用了智能指针的方案,进一步理解了面向对象编程中 多态 这一个概念后,我开始照着Maxxing的示例进行编写.
我创建了 `ast.h`, `ast.cpp`, `include.h` , 分别用来保存ast中相关类的定义,ast中各个类中Dump()函数的编写.以及原来的一些头文件.

`ast.h`

```cpp
#pragma once

#include "include.h"

class BaseAST {
public:
    virtual ~BaseAST() = default;
    virtual void Dump() const = 0;
};

class CompUnitAST : public BaseAST {
public:
    std::unique_ptr<BaseAST> fun_def;
    void Dump() const override;
};

class FunDefAST : public BaseAST {
public:
    std::unique_ptr<BaseAST> fun_type;
    std::string ident;
    std::unique_ptr<BaseAST> block;
    void Dump() const override;
};

class FunTypeAST : public BaseAST {
public:
    std::string tp;
    void Dump() const override;
};

class BlockAST : public BaseAST {
public:
    std::unique_ptr<BaseAST> stmt;
    void Dump() const override;
};

class StmtAST : public BaseAST {
public:
    std::string retrn = "return";
    std::unique_ptr<BaseAST> number;
    std::string fenhao = ";";
    void Dump() const override;
};

class NumberAST : public BaseAST {
public:
    int int_const;
    void Dump() const override;
};

```

`ast.cpp`

```cpp

#include "include.h"
#include "ast.h"

void CompUnitAST :: Dump() const {
    std::cout << "CompUnitAST { ";
    fun_def -> Dump();
    std::cout << " } ";
}

void FunDefAST :: Dump() const{
    std::cout << "FuncDefAST { ";
    fun_type -> Dump();
    std::cout << ident << " ( ) ";
    block -> Dump();
    std::cout << " } " ;
}

void FunTypeAST :: Dump() const{
    std::cout << "FuncTypeAST { ";
    std::cout << tp ;
    std::cout << " } ";
}


void BlockAST :: Dump() const{
    std::cout << "BlockAST { ";
    stmt -> Dump() ;
    std::cout << " } ";    
}

void StmtAST :: Dump() const{
    std::cout << "StmtAST { ";
    std::cout << retrn;
    number -> Dump();
    std::cout << fenhao;
    std::cout << " } ";
}

void NumberAST :: Dump() const{
    std::cout << int_const;
}
```

了解了智能指针的用法后,这些还是比较容易写出来的,就是有点费时间.

然后在 `sysy.y` 照着示例将所有字符串更新成为 `AST` 类即可.

写完后我遇到了两个问题,第一是在 `Stmt` 返回的第二个参数返回的类型,和我设计的预期不符合

```cpp
Stmt
  : RETURN Number ';' {
    auto numbr = new StmtAST();
    numbr -> number = unique_ptr<BaseAST>($2);
    $$ = numbr;
  }
  ;
```

这其实是照着教程给非终结符定义的时候将`Number` 定义成了 `int_val` 导致 `($2)` 的返回值是一个int ,导致错误.

把`Number` 加入了 `ast_val` 后就成功解决了.

第二个问题是链接的时候出现问题, `*.cpp` 类型的文件都不能放在别的文件的 `include` path 当中,会重复定义.

删除了这些 `ast.cpp` 就ok了.

得到结果

![image](/image/AST.png)

 9-15

### Lv1.4. IR 生成

这一节,演示代码几乎消失不见了,只剩下我们需要实现的目标:

1. 我们应该生成一个 Koopa IR 程序.
2. 程序中有一个名字叫 main 的函数.
3. 函数里有一个入口基本块.
4. 基本块里有一条返回指令.
5. 返回指令的返回值就是 SysY 里 return 语句后跟的值, 也就是一个整数常量.

并且最后生成一个这个程序:

```koopa
fun @main(): i32 {  // main 函数的定义
%entry:             // 入口基本块
  ret 0             // return 0
}
```

打算用 `vector<unique_ptr<xxx>>` 之类的来存.今日进度不佳.

9-16

我定义好了 `Ir.h` 和 `Ir.cpp` 里的内容,定义好了如何 IR 里的内容.方法和 AST 类似,Dump()函数也类似.这回也是纯纯手写代码上了.

现在就是写 IRGenerator 的时间,我本来想使用函数式定义这个 GENERATOR 不过考虑到这个函数可能会过于庞大,还是用类来定义了.

这是我初版的 IRGenerator 的定义:

```cpp
class IRGenerator {
private:
    std::unique_ptr<IRProgram> program;
    static int blockcount;
    
public:
    IRGenerator(){};
    void visitCompUnit(const CompUnitAST* ast);
    void visitFunDef(const FunDefAST* ast);
    void visitFunType(const FunTypeAST* ast);
    void visitBlock(const BlockAST* ast);
    void visitStmt(const StmtAST* ast);
    void visitNumber(const NumberAST* ast);
    std::unique_ptr<IRProgram> get_irprogram();
};
```

比较好理解,不过这里每一个 visit 函数的参数并没有使用 `unique_ptr<BaseAST>` 的类型,使用了各种 AST 分别的类的指针,会安全一些.

但是,我在之前生成 AST 的时候,基于多态性质,利用的所有指针都是 BaseAST 类型的,怎么才能优秀的传入 visit 函数的参数中呢?

```cpp
if (ast && ast->fun_def) {
    if (auto func_def = dynamic_cast<FunDefAST*>(ast->fun_def.get())) {
        visitFuncDef(func_def);
    }
}
```

这个代码是 ai 生成的 ,我觉得很有意思,它做了这些事情:

```cpp
void IRGenerator::visitCompUnit(const CompUnitAST* ast) {
    // 步骤1：检查 ast 指针是否有效
    if (!ast) {
        std::cout << "CompUnitAST is null!" << std::endl;
        return;
    }
    
    // 步骤2：检查 fun_def 成员是否存在
    if (!ast->fun_def) {
        std::cout << "fun_def is null!" << std::endl;
        return;
    }
    
    // 步骤3：检查 fun_def 的实际类型是否是 FunDefAST
    auto func_def = dynamic_cast<const FunDefAST*>(ast->fun_def.get());
    if (!func_def) {
        std::cout << "fun_def is not a FunDefAST!" << std::endl;
        return;
    }
    
    // 步骤4：安全地调用 visitFuncDef
    visitFuncDef(func_def);
}
```

`dynamic_cast<目标类型>(源对象)` 这个函数的作用是尝试将源对象转化成目标类型, 如果失败返回 `nullptr`,十分满足我的需求.不过,需要注意的是,该操作虽然安全,但是有性能开销,还有一种函数是 `static_cast` 这个会快速一些,但是会导致未定义行为,以后的实践可能会用到这个优化.

我觉得可以学习这种写法,优秀的解决了参数类型的问题,还带有检测ast以及ast -> fun_def是否为空的问题.

9-17

顺利的写出了IR的内容.

修改了 `IRGenerator` 里 visit 函数的定义 , 给visit Block等函数添加了 `IRBasicBlock*` 类的参数.

给参数是指针的函数传递参数的时候,要使用 `std::move()` 转移所有权,不然会出现问题;

### Lv1.5. 测试

按照要求,我更新了我的 `run.sh` 的内容,添加了测试的功能.

```sh
#!/bin/bash

# 获取项目目录的绝对路径
PROJECT_DIR=$(pwd)

# 检查第一个参数
if [ "$1" = "test" ]; then
    # 测试模式：运行 autotest
    sudo docker run -it --rm -v $PROJECT_DIR:/root/compiler maxxing/compiler-dev \
        autotest -koopa -s "$2" /root/compiler
else
    # 默认模式：进入交互式 bash
    sudo docker run -it --rm -v $PROJECT_DIR:/root/compiler maxxing/compiler-dev bash -c "
        cd compiler &&
        cmake -DCMAKE_BUILD_TYPE=Debug -B build &&
        cmake --build build &&
        cd build &&
        bash
    "
fi
```

输入`./run.sh test lv1`就可以 开始测试了.

这回没过第二个测试点,原来是遗留的作业没有做完,多行匹配.

CSDN 经过几年的运营 ,越来越差了, 基本都是垃圾, 不垃圾的需要冲会员.

在 `.l` 里写了多行匹配的正则表达式之后,就完成了测试.

## Lv2. 初试目标代码生成 

### Lv2.1. 处理Koopa IR

由于我写出来的IRGenerator是存储在内存当中的,所以这一节跳过.

<br>

### Lv2.2. 目标代码生成

我需要把
```ir
fun @main() : i32 {
%entry0 :
  ret 0 
}
```

变成

```asm
  .text
  .globl main
main:
  li a0, 0
  ret
```

这样的汇编代码,我准备在每个 Value 的类中添加转化成Risc-V的代码,应该不会很复杂.

 9-19

我在所有的 `value` `basicblock` `function` `program` IR 类中添加了To_Riscv 函数，按照实例代码翻译即可，还是很容易的.

这里我给之前的代码做出一些修改，将return Number 这个操作合并到ReturnValue 这个类中，这样就不会出现生成koopa IR和生成RiscV汇编的时候出现ret 和number 顺序出错的问题了.

### Lv2.3. 测试

我又更新了我的 run.sh 增加了一个参数 ，可以手动选择测试的时候要 `-koopa` 还是 `-riscv` .

这是更新后的代码

```sh
#!/bin/bash

# 获取项目目录的绝对路径
PROJECT_DIR=$(pwd)

# 检查第一个参数
if [ "$1" = "test" ]; then
    # 测试模式：运行 autotest
    sudo docker run -it --rm -v $PROJECT_DIR:/root/compiler maxxing/compiler-dev \
        autotest "$2" -s "$3" /root/compiler
else
    # 默认模式：进入交互式 bash
    sudo docker run -it --rm -v $PROJECT_DIR:/root/compiler maxxing/compiler-dev bash -c "
        cd compiler &&
        cmake -DCMAKE_BUILD_TYPE=Debug -B build &&
        cmake --build build &&
        cd build &&
        bash
    "
fi
```

可能是之前写AST和IR都选择了纯手写，保存IR到内存，所以第二章需要增添的内容挺少的，顺利通过了第二章。

## Lv3. 表达式

### Lv3.1. 一元表达式

本章我要完成这样一个EBNF

```text
Stmt        ::= "return" Exp ";";

Exp         ::= UnaryExp;
PrimaryExp  ::= "(" Exp ")" | Number;
Number      ::= INT_CONST;
UnaryExp    ::= PrimaryExp | UnaryOp UnaryExp;
UnaryOp     ::= "+" | "-" | "!";
```

要将Stmt重写.

9-21

> 天下英雄如过江之鲫

我感觉要走的路还是太长了,走着走着就迷茫了.

我定义好了 AST 并且写出了对应的 Bison 内容,明天写 IR 的内容.
